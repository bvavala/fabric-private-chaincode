/'
    Copyright 2020 Intel Corporation
    Copyright IBM Corp. All Rights Reserved.

    SPDX-License-Identifier: Apache-2.0
'/

@startuml

!pragma teoz true

hide footbox
title Foot Box removed

title Fabric Private Chaincode - Lifecycle v2

box "Org1"
actor	Admin order 10
entity "FPC_Peer1_Wrapper" as FPC_Peer1_Wrapper order 15
participant Peer1 order 20
entity "FPC_Peer2_Wrapper" as FPC_Peer2_Wrapper order 30
participant Peer2 order 40
end box

box "Channel Abstraction"
participant Channel order 70
note over Channel
    This box abstracts all other orgs and components.
    Actions are supposed to be performed by channel participants.
end note
end box

entity Orderer order 80

note over Admin
    Admin uses the fpc-peer wrappers, which abstract the Fabric Peer CLI.
end note

group chaincode package
Admin -> FPC_Peer1_Wrapper : lifecycle chaincode package
note right
    **Chaincode package**
    as tar.gz with
    metadata.json = <path:(enclaves_path), type:(cc_lang), label:(cc_label), sgx_mode: (sim/hw)>
    code.tar.gz : compressed file with enclave binary and mrenclave
end note
return
end /' group chaincode package '/

group install
Admin -> FPC_Peer1_Wrapper ++: lifecycle chaincode install
FPC_Peer1_Wrapper -> Peer1 ++: lifecycle chaincode install
return packageId
note over FPC_Peer1_Wrapper
    The following bookking operations help remember (across lifecycle calls)
    that a package (id) corresponds to a FPC chaincode. Similarly, the
    approve will later store data for an FPC chaincode installed locally,
    and the commit checks for data of a locally-approved FPC chaincode.
    Also, it should be noted that
    - the install lifecycle op is peer-specific, while
    - the approveformyorg is org-specific, to be run on at most one org's peer
    - the and commit op is expected to run on a single peer
    Hence, the current bookeeping ops expect the approve and commit ops to
    run on peers where the FPC chaincode has been previously installed.
end note
FPC_Peer1_Wrapper -> FPC_Peer1_Wrapper : retrieve cc_language from package
FPC_Peer1_Wrapper -> FPC_Peer1_Wrapper : if cc_language==fpc then store packageId
return packageId /' Admin -> FPC_Peer1_Wrapper '/
end /' group install '/

ref over Admin, FPC_Peer2_Wrapper, Peer2
    install chaincode on Peer2
end /' ref '/

group local approve
Admin -> FPC_Peer1_Wrapper ++: lifecycle chaincode approveformyorg
FPC_Peer1_Wrapper -> Peer1 ++: lifecycle chaincode approveformyorg
note right
    **Chaincode definition**
    Name: cc_name, Version: mrenclave,
    Sequence: sequence_number, Endorsement Policy: (2of3),
    Plugins: <custom endorsement/validation plugins>
end note
Peer1 -> Orderer ++: approve transaction
return transaction committed /' Peer1 -> Orderer '/
return /' FPC_Peer1_Wrapper -> Peer1 '/
note over FPC_Peer1_Wrapper
    Bookkeping operations.
    Note: packageId is an input parameter of approveformyorg
end note
FPC_Peer1_Wrapper -> FPC_Peer1_Wrapper : if packageId was stored then store cc_namie, cc_version
return /' Admin -> FPC_Peer1_Wrapper '/
end /' group approve '/

group other orgs approve
Channel -> Channel : approvals from other parties
note over Channel
    Other participants must approve the chaincode definition,
    and commit the corresponding transaction,
    according to the LifecycleEndorsement policy.
    So the party here has to loop to check for the approvals.
end note
end group 'other orgs approve'


loop until enough approvals
	Admin -> Peer1 : lifecycle chaincode checkcommitreadiness
note right
    **Chaincode definition**
    (implemented to match the approved one)
end note
    return
end

group commit
Admin -> FPC_Peer1_Wrapper ++:lifecycle chaincode commit
FPC_Peer1_Wrapper -> Peer1 ++: lifecycle chaincode commit
note right
    **Chaincode definition**
    (implemented to match the one that is ready to be committed)
end note
Peer1 -> Orderer ++: commit transaction
return transaction committed /' Peer1 -> Orderer '/
return /' FPC_Peer1_Wrapper -> Peer1 '/
note over FPC_Peer1_Wrapper
    Commit has succeeded.
    Now, check if this fpc cc was previously approved.
    If so, perform some invocations.
end note
FPC_Peer1_Wrapper -> FPC_Peer1_Wrapper : if cc_name, cc_version not stored then return
FPC_Peer1_Wrapper -> Peer1 ++: invoke chaincode __setup
Peer1 -> Orderer ++: invoke transaction
return transaction committed
return /' FPC_Peer1_Wrapper -> Peer1 '/
FPC_Peer1_Wrapper -> Peer1 ++: query chaincode __getEnclavePk
return /' FPC_Peer1_Wrapper -> Peer1 '/
return /' Admin -> FPC_Peer1_Wrapper '/
end /' group commit '/

@enduml
